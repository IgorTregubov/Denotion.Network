+++
title = "Programming is difficult"
date = 2023-04-05T22:30:46+03:00
draft = false
image = "images/blog/programming_is_difficult_thumbnail.webp"
+++

Complexity can be defined as the degree of heterogeneity of a system. If the components of the system are diverse, and the connections between them are varied, then the complexity of such a system is higher. The complexity of the universe, consisting of identical bricks, is equal to the complexity of a single brick and its connections with neighboring bricks (the complexity reduction theorem). Therefore, complexity expresses not the mass-energy characteristics of the world (see E = mc2), but its structural properties, which can be very rich and general.

Developers of programs face complexity exclusively. Programs do not have mass or energy (if we discard the hardware parameters on which they are executed). Programs are pure structures, and complexity is one of the main integral parameters of these structures. Programmers devote their lives to struggling with complexity, but often this struggle is hopeless, because they do not understand the laws of the world in which they operate structural constructions, hierarchies of classes, or dictionaries. Programmers are heroes of the "invisible front" in the fight against colossal volumes of ignorance; heroes who are armed with useless rattles instead of real tools for understanding the truth. Real professionals quickly realize that developers of programming languages such as C/C++ or Pascal/Modula/Oberon and producers of such tools simply confuse their heads, offering only generators of random walks in the state space of the problem. In search of a solution, some try to create their own tools (which often fails), but most discover non-linguistic programming tools. This is already good, because stupidity, such as the ++ sign priority, does not prevent them from seeing the essence of the matter. Then the realization of the "size of the disaster" appears. But the realization of the problem is already half the solution...

In programming, the main problem is managing the complexity of a program, which must be evenly distributed throughout the program's text to avoid overloading and errors. Human perception abilities are limited, so it is necessary to avoid complex clusters in important parts of the program, which can lead to real errors. This is not an error in understanding the task, but a natural limitation of the learning process, which is infinite.

Rewriting a calculus textbook without formulas can take up significantly more space than the original and not provide clear instructions for practical use due to the lack of concise and clear recipes for typical situations. This is explained by the concept of "text metrics," which means that modern programming tools are quasi-mathematical and the metrics generated by their texts are not as serious as the metrics of ordinary mathematical texts. This is because mathematical text is always constructed in terms of the problem being solved, whereas programming tools represent a set of rigid commands with limited semantics. The translation of task terms into terms of the target language occurs mainly manually, and this is the root cause of all the problems that need to be solved when using new programming technologies.

In general, it can be noted that to solve this problem, it is necessary to create a new technology that would represent a formalism that is not a machine algorithm, but is understandable and simple for humans. This formalism should allow the formulation of the problem and its solution methods in the language of the problem itself, using only one automation - the automation of complexity separation and control. The main goal of such automation is to give full control over any part of the problem solution, even to non-programmers who can only perceive 4-7 elements of information simultaneously.

Today, there are many ways to implement automatic complexity separation, such as logic-matrix methods, special logics (such as temporal and fuzzy logics), factorization methods, event-oriented protocols for process interaction, and others. However, the question is not whether such a system can be created, but rather what form and specific set of tools will be used to implement it.
