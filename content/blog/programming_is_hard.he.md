+++
title = "קשה לתכנות"
date = 2023-04-05T22:30:46+03:00
draft = false
image = "images/blog/programming_is_difficult_thumbnail.webp"
+++

ניתן להגדיר מורכבות כמידת ההטרוגניות של מערכת. אם מרכיבי המערכת מגוונים, והקשרים ביניהם מגוונים, הרי שהמורכבות של מערכת כזו גבוהה יותר. המורכבות של היקום, המורכב מלבנים זהות, שווה למורכבות של לבנה בודדת ולקשריה עם לבנים שכנות (משפט הפחתת המורכבות). לכן, מורכבות לא מבטאת את מאפייני האנרגיה המונית של העולם, אלא את התכונות המבניות שלו, שיכולות להיות עשירות וכלליות מאוד.

מפתחי תוכניות מתמודדים באופן בלעדי עם מורכבות. לתוכניות אין מסה או אנרגיה (אם נזרוק את פרמטרי החומרה עליהם הן מבוצעות). תוכניות הן מבנים טהורים, ומורכבות היא אחד הפרמטרים האינטגרליים העיקריים של מבנים אלה. מתכנתים מקדישים את חייהם למאבק במורכבות, אך לעתים קרובות המאבק הזה הוא חסר סיכוי, מכיוון שהם אינם מבינים את חוקי העולם שבו הם מפעילים מבנים מבניים, היררכיות של מעמדות או מילונים. מתכנתים הם גיבורי "החזית הבלתי נראית" במאבק בכמויות עצומות של בורות; גיבורים חמושים ברעשנים חסרי תועלת במקום בכלים אמיתיים להבנת האמת. אנשי מקצוע אמיתיים מבינים מהר מאוד שמפתחי שפות תכנות כמו C/C++ או Pascal/Modula/Oberon ומפיקים של כלים כאלה פשוט מבלבלים את ראשם, ומציעים רק מחוללי הליכה אקראיים במרחב המצב של הבעיה. בחיפוש אחר פתרון, חלקם מנסים ליצור כלים משלהם (שלרוב נכשל), אך רובם מגלים כלי תכנות לא לשוניים. זה כבר טוב, כי טיפשות, כמו עדיפות סימן ++, לא מונעת מהם לראות את מהות העניין. ואז מופיעה מימוש "גודל האסון". אבל מימוש הבעיה הוא כבר חצי מהפתרון...

בתכנות, הבעיה העיקרית היא ניהול המורכבות של תוכנית, אשר חייבת להיות מפוזרת באופן שווה בכל הטקסט של התוכנית כדי למנוע עומס יתר ושגיאות. יכולות התפיסה האנושיות מוגבלות, ולכן יש צורך להימנע מאשכולות מורכבים בחלקים חשובים של התוכנית, שעלולים להוביל לטעויות של ממש. אין זו טעות בהבנת המשימה, אלא מגבלה טבעית של תהליך הלמידה, שהוא אינסופי.

שכתוב ספר חישוב ללא נוסחאות יכול לתפוס מקום משמעותי יותר מהמקור ולא לספק הנחיות ברורות לשימוש מעשי בשל היעדר מתכונים תמציתיים וברורים למצבים אופייניים. זה מוסבר על ידי המושג "מדדי טקסט", שפירושו שכלי התכנות המודרניים הם כמעט מתמטיים והמדדים שנוצרים מהטקסטים שלהם אינם רציניים כמו המדדים של טקסטים מתמטיים רגילים. הסיבה לכך היא שטקסט מתמטי נבנה תמיד במונחים של הבעיה הנפתרת, בעוד שכלי תכנות מייצגים קבוצה של פקודות נוקשות עם סמנטיקה מוגבלת. תרגום מונחי המשימה למונחים של שפת היעד מתרחש בעיקר באופן ידני, וזהו הגורם השורשי לכל הבעיות שיש לפתור בעת שימוש בטכנולוגיות תכנות חדשות.

באופן כללי, ניתן לציין שכדי לפתור בעיה זו, יש צורך ליצור טכנולוגיה חדשה שתייצג פורמליזם שאינו אלגוריתם מכונה, אלא מובן ופשוט לבני אדם. פורמליזם זה אמור לאפשר ניסוח הבעיה ודרכי הפתרון שלה בשפת הבעיה עצמה תוך שימוש באוטומציה אחת בלבד – אוטומציה של הפרדה ובקרה של מורכבות. המטרה העיקרית של אוטומציה כזו היא לתת שליטה מלאה על כל חלק בפתרון הבעיה, אפילו למתכנתים שאינם יכולים לתפוס רק 4-7 אלמנטים של מידע בו זמנית.

כיום, ישנן דרכים רבות ליישם הפרדת מורכבות אוטומטית, כגון שיטות לוגיקה-מטריקס, לוגיקה מיוחדת (כגון לוגיקה זמנית ומטושטשת), שיטות פירוק לגורמים, פרוטוקולים מוכווני אירועים לאינטראקציה בין תהליכים ועוד. עם זאת, השאלה היא לא האם ניתן ליצור מערכת כזו, אלא באיזו צורה ומערכת ספציפית של כלים ישמשו ליישם אותה.